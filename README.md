# Практическая работа по дисциплине "Инженерия информационных систем"

## Практическая работа 1. Паттерн Strategy.

[Source](https://github.com/Malomalsky/Patterns/blob/master/Strategy.py)

**Тип:** Поведенческий

**Cуть**

Определяет группу алгоритмов (каждый алгоритм - отдельный класс), инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

**Когда применяется:**

* Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
* Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
* Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора      представляет собой вариацию алгоритма.


**Как работает в данной работе:**

Определяем общий контекст, в котором работает клиент; одно из свойств контекста - @strategy - позволяет менять стратегию (алгоритм) во время работы программы. Далее обьявляем абстрактный класс Strategy; после этого - конкретные стратегии, наследуемые от него. В примере: Strategy A - обычная сортировка, Strategy B - обратная сортировка, Strategy C - пузырьковая. 
В программу пользователь заносит последовательность чисел, а программа сортирует ее разными алгоритмами.
***

## Практика 2. Паттерны Iterator и Observer

### Итератор

[Source](https://github.com/Malomalsky/Patterns/blob/master/iterator2.py)

**Тип** Поведенческий

**Суть**

Предоставляет способ последовательного доступа к элементам множества, независимо от его внутреннего устройства

**Когда применяется** 

* Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).
*  Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
*  Когда вам хочется иметь единый интерфейс обхода различных структур данных.

### Обсервер (наблюдатель)

[Source](https://github.com/Malomalsky/Patterns/blob/master/Observer.py)

**Тип** Поведенческий

**Суть**

Определяет зависимость "один-ко-многим" между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляеются автоматически.

**Когда применяется**

* Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.
* Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

### Совместная работа Итератора и Наблюдателя.

К сожалению, код программы безвозвратно утерян при обновлении системы :^(

**Cуть**

Генерируется граф; его вершины имею рандомные числа от 1 до 100. Итератор обходит граф, за процессом следит обсервер. Если значение числа вершины - целое число, обсервер обовещает об этом конкретного наблюдателя, который меняет значение объекта colormap (по умолчанию, все вершины - синего цвета; обсервер меняет цвет вершины на красный). На выходе - визуализация графа с вершинами соответствующего цвета. 

***

## Практическая работа 3. Абстрактная фабрика (в моем случае - фабричый метод) и Билдер (строитель).

### Абстрактная фабрика

**Тип** Порождающий

**Суть**

Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

**Когда применяется**

* Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
* Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
 
 
 ### Фабричный метод
 
 **Тип** Порождающий
 
 **Суть**
 
 Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
 
 **Когда применяется**
 
 * Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
 * Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
 
 ### Совместная работа
 
 **Фабричный метод**  - сначала объявляется абстрактный создатель. От него наследуются два конкретных - **ShipCreator** и **TruckCreator**. Каждый из создателей пораждает объект класса **Корабль** и **Грузовик** соответственно, при этом логируя информацию о создании в [базу данных SQLite](https://github.com/Malomalsky/Patterns/blob/master/db.sqlite). Далее объявляется абстрактный класс **Product**, и от него наследуются два конкретных продукта - **Ship** и **Truck**
 
**Строитель** - объявляем абстрактного билдера, затем наследуем от него **ConcreteBuilder1**. Данный класс имеет методы **produce_part_a**, в котором задается техническая информация письма (адресат, отправитель и прочее), и **produce_part_b**, в котором составляется основная часть письма (делается запрос к БД, формируется отчет о количестве созданных объектов с рекомендацией).

Программа выполняет 100 итераций, где каждую итерацию рандомно создается либо корабль, либо грузовик, а каждую 30 итерацию билдером формируется и отправляется письмо из логов с рекомендацией. 




