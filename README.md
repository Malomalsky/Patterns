# Практическая работа по дисциплине "Инженерия информационных систем"

## Практическая работа 1. Паттерн Strategy.

[Source](https://github.com/Malomalsky/Patterns/blob/master/Strategy.py)

**Тип:** Поведенческий

**Cуть**

Определяет группу алгоритмов (каждый алгоритм - отдельный класс), инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

**Когда применяется:**

* Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
* Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
* Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора      представляет собой вариацию алгоритма.


**Как работает в данной работе:**

Определяем общий контекст, в котором работает клиент; одно из свойств контекста - @strategy - позволяет менять стратегию (алгоритм) во время работы программы. Далее обьявляем абстрактный класс Strategy; после этого - конкретные стратегии, наследуемые от него. В примере: Strategy A - обычная сортировка, Strategy B - обратная сортировка, Strategy C - пузырьковая. 
В программу пользователь заносит последовательность чисел, а программа сортирует ее разными алгоритмами.
***

## Практика 2. Паттерны Iterator и Observer

### Итератор

[Source](https://github.com/Malomalsky/Patterns/blob/master/iterator2.py)

**Тип** Поведенческий

**Суть**

Предоставляет способ последовательного доступа к элементам множества, независимо от его внутреннего устройства

**Когда применяется** 

* Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).
*  Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
*  Когда вам хочется иметь единый интерфейс обхода различных структур данных.

### Обсервер (наблюдатель)

[Source](https://github.com/Malomalsky/Patterns/blob/master/Observer.py)

**Тип** Поведенческий

**Суть**

Определяет зависимость "один-ко-многим" между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляеются автоматически.

**Когда применяется**

* Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.
* Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

### Совместная работа Итератора и Наблюдателя.

К сожалению, код программы безвозвратно утерян при обновлении системы :^(

**Cуть**

Генерируется граф; его вершины имею рандомные числа от 1 до 100. Итератор обходит граф, за процессом следит обсервер. Если значение числа вершины - целое число, обсервер обовещает об этом конкретного наблюдателя, который меняет значение объекта colormap (по умолчанию, все вершины - синего цвета; обсервер меняет цвет вершины на красный). На выходе - визуализация графа с вершинами соответствующего цвета. 

***

## Практическая работа 3. Абстрактная фабрика (в моем случае - фабричый метод) и Билдер (строитель).

### Абстрактная фабрика

**Тип** Порождающий

**Суть**

Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

**Когда применяется**

* Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
* Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
 
 
 ### Фабричный метод
 
 **Тип** Порождающий
 
 **Суть**
 
 Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
 
 **Когда применяется**
 
 * Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
 * Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
 
 ### Совместная работа
 
 [Source](https://github.com/Malomalsky/Patterns/blob/master/fm_builder.py)
 
 **Фабричный метод**  - сначала объявляется абстрактный создатель. От него наследуются два конкретных - **ShipCreator** и **TruckCreator**. Каждый из создателей пораждает объект класса **Корабль** и **Грузовик** соответственно, при этом логируя информацию о создании в [базу данных SQLite](https://github.com/Malomalsky/Patterns/blob/master/db.sqlite). Далее объявляется абстрактный класс **Product**, и от него наследуются два конкретных продукта - **Ship** и **Truck**
 
**Строитель** - объявляем абстрактного билдера, затем наследуем от него **ConcreteBuilder1**. Данный класс имеет методы **produce_part_a**, в котором задается техническая информация письма (адресат, отправитель и прочее), и **produce_part_b**, в котором составляется основная часть письма (делается запрос к БД, формируется отчет о количестве созданных объектов с рекомендацией).

Программа выполняет 100 итераций, где каждую итерацию рандомно создается либо корабль, либо грузовик, а каждую 30 итерацию билдером формируется и отправляется письмо из логов с рекомендацией. 

***

## Практическая работа 4. Цепочка обязанностей и делегация полномочий.

### Цепочка обязанностей

**Тип** Поведенческий

**Суть** 

Избегает связывания отправителя запроса с его получателем, давай возможность обработать запрос более чем одному объекту. Связывает объекты-получатели и передает запро по цепочке пока объект не обработает его. 

**Как работает в моей работе** 

Пользователь формирует покупательскую [корзину](https://github.com/Malomalsky/Patterns/blob/master/cli.py), затем начинается работа **цепочки обязанностей**. В ней мы сначала обьявляем класс **Handler** с методом построения цепочки обработчиков. Далее объявляем AbstractHandler и конкретных обработчиков - BagHandler, CourierHandler, AirHandler. Каждый обработчик обрабатывает конкретные товары. Затем, как пользователь сформировал корзину, начинается процесс обработки, и контекст показывает, какой товар как доставляется, исходя из заданной цепочки. 


### Делегация полномочий

**Тип** Поведенческий

**Суть** 


Объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. Шаблон делегирования является фундаментальной абстракцией, на основе которой реализованы другие шаблоны - композиция (также называемая агрегацией), примеси (mixins) и аспекты (aspects). 

###

## Практическая работа 5. MVC/MVVM 

Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.

* Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
* Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели.
* Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.

В моем [примере](https://github.com/Malomalsky/Patterns/tree/master/locallibrary) модель MVC реализуется на базе фреймворка Django. Говорят они о себе так:
> Django appears to be a MVC framework, but you call the Controller the “view”, and the View the “template”. How come you don’t use the standard names?¶

> Well, the standard names are debatable.

> In our interpretation of MVC, the “view” describes the data that gets presented to the user. It’s not necessarily how the data looks, but which data is presented. The view describes which data you see, not how you see it. It’s a subtle distinction.

> So, in our case, a “view” is the Python callback function for a particular URL, because that callback function describes which data is presented.

> Furthermore, it’s sensible to separate content from presentation – which is where templates come in. In Django, a “view” describes which data is presented, but a view normally delegates to a template, which describes how the data is presented.

> Where does the “controller” fit in, then? In Django’s case, it’s probably the framework itself: the machinery that sends a request to the appropriate view, according to the Django URL configuration.

> If you’re hungry for acronyms, you might say that Django is a “MTV” framework – that is, “model”, “template”, and “view.” That breakdown makes much more sense.

> At the end of the day, of course, it comes down to getting stuff done. And, regardless of how things are named, Django gets stuff done in a way that’s most logical to us.

Файл models.py содержит описание таблицы базы данных, представленное в виде класса Python. Такой класс называется моделью. С помощью данного класса вы можете создавать, получать, обновлять и удалять записи в таблице вашей базы данных, используя простой код на языке Python вместо использования повторяющихся SQL команд.

Файл views.py содержит логику отображения страницы в функции latest_books(). Такая функция называется представлением.

 Файл urls.py определяет какое именно представление будет вызвано для URL, заданного в виде шаблона. В данном случае URL /latest/ будет обработано функцией latest_books(). Другими словами, если имя вашего домена example.com, то любой доступ к http://example.com/latest/ будет обработан функцией latest_books().

Файл latest_books.html является HTML шаблоном, который описывает дизайн страницы. Он использует шаблонный язык с основными логическими операторами — {% for book in book_list %}. 

Объединённые вместе, эти компоненты приложения следуют шаблону Модель-Представление-Контроллёр (Model-View-Controller, MVC). Примем, что MVC определяет способ разработки программного обеспечения при котором код для определения и доступа к данным (модель) отделён от логики приложения (управление), которая в свою очередь отделена от интерфейса пользователя (представление).

Основное преимущество такого подхода заключается в свободе объединения этих компонентов. Следовательно, каждая отдельная часть приложения, созданного с помощью Django, имеет одно назначение и может быть изменена независимо, т.е., без влияния на остальные компоненты. Например, разработчик может изменить URL для данной части приложения без изменения остального кода. Дизайнер может изменить HTML страницы без внесения изменений в код, который отображает страницу. Администратор базы данных может переименовать таблицу и определить эти изменения в одном месте, вместо того, чтобы искать и вносить изменения во множество файлов.


**Как работает** 

Заходим в папку, пишем 
<python manage.py runserver>


Заходим на http://127.0.0.1:8000/

