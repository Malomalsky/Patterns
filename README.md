# Практическая работа по дисциплине "Инженерия информационных систем"

## Практическая работа 1. Паттерн Strategy.

[Source](https://github.com/Malomalsky/Patterns/blob/master/Strategy.py)

**Тип:** Поведенческий

**Cуть**

Определяет группу алгоритмов (каждый алгоритм - отдельный класс), инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

**Когда применяется:**

* Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
* Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
* Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора      представляет собой вариацию алгоритма.


**Как работает в данной работе:**

Определяем общий контекст, в котором работает клиент; одно из свойств контекста - @strategy - позволяет менять стратегию (алгоритм) во время работы программы. Далее обьявляем абстрактный класс Strategy; после этого - конкретные стратегии, наследуемые от него. В примере: Strategy A - обычная сортировка, Strategy B - обратная сортировка, Strategy C - пузырьковая. 
В программу пользователь заносит последовательность чисел, а программа сортирует ее разными алгоритмами.
***

## Практика 2. Паттерны Iterator и Observer

### Итератор

[Source](https://github.com/Malomalsky/Patterns/blob/master/iterator2.py)

**Тип** Поведенческий

**Суть**

Предоставляет способ последовательного доступа к элементам множества, независимо от его внутреннего устройства

**Когда применяется** 

* Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).
*  Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
*  Когда вам хочется иметь единый интерфейс обхода различных структур данных.

### Обсервер (наблюдатель)

[Source](https://github.com/Malomalsky/Patterns/blob/master/Observer.py)

**Тип** Поведенческий

**Суть**

Определяет зависимость "один-ко-многим" между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляеются автоматически.

**Когда применяется**

* Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.
* Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

### Совместная работа Итератора и Наблюдателя.

К сожалению, код программы безвозвратно утерян при обновлении системы :^(

**Cуть**

Генерируется граф; его вершины имею рандомные числа от 1 до 100. Итератор обходит граф, за процессом следит обсервер. Если значение числа вершины - целое число, обсервер обовещает об этом конкретного наблюдателя, который меняет значение объекта colormap (по умолчанию, все вершины - синего цвета; обсервер меняет цвет вершины на красный). На выходе - визуализация графа с вершинами соответствующего цвета. 

***

## Практическая работа 3. Абстрактная фабрика (в моем случае - фабричый метод) и Билдер (строитель).

### Абстрактная фабрика


